page: test
    module: python

    test()

fncode: test
    f = open('test.html')
    s = f.read()

    # print (s)

    root_node = parse_html(s)
    # print "root_node: ", type(root_node), "\n"
    # debug_dom(root_node)

fncode: parse_html(s)
    $call init_parse_stack

    DUMP_STUB regex_compile
    $list parse_attribute

    &call parse_loop, s
        &call if_match_continue, <!--.*?-->
            #-- comment ----
        &call if_match_continue, <!DOCTYPE.*?>
            #-- doctype ----
        &call if_match_continue, [^<]+
            #-- text node ----
            cur_list.append: m.group(0)
        &call if_match_continue, <(\w+)(.*?)>
            #-- start tag ----
            s_name=m.group(1)
            s_attr=m.group(2)
            $call match_start_tag
        &call if_match_continue, </(\w+).*?>
            #-- end tag ----
            s_name=m.group(1)
            $call match_end_tag

        #-- error: lone < char --
        i+=1

    return tag_stack[0]

    # ------------------------------
    subcode:: init_parse_stack
        tag_stack=[]
        cur_list=[]
        tag_stack.append: {'_name':'root', '_list':cur_list}
        # debug_dom(tag_stack[0])

    subcode: match_start_tag
        tag = {'_name':s_name}
        parse_attribute(tag, s_attr)

        cur_list.append: tag

        if '/' in tag or re.match(r"area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr", s_name):
            #-- empty --
            pass
        elif re.match(r"script|style|textarea|title", s_name):
            #-- raw text --
            $call scan_raw_text
        else :
            tag_stack.append: tag
            cur_list=[]
            tag['_list'] = cur_list

    subcode: match_end_tag
        $if s_name == tag_stack[-1]['_name']
            tag_stack.pop()
            cur_list=tag_stack[-1]['_list']
        $else
            #-- error --
            #-    drop missed tags or do nothing
            j=len(tag_stack)-2
            while j>0:
                if s_name == tag_stack[j]['_name']
                    while len(tag_stack)>=j
                        tag_stack.pop()
                    cur_list=tag_stack[-1]['_list']
                    break
                j-=1

    # ----------------------------
    subcode: scan_raw_text
        i_start=i
        &call sub_loop
            &call if_match_continue, ([^<]|<[^/])+
                # -- include
            &call if_match_single, </(\w+).*?>
                $if m.group(1)==s_name
                    break
                $else
                    continue
            i+=1
        i_end=i

        tag['_text'] = s[i_start:i_end]


#---------------------------------------- 
fncode: parse_attribute(tag, s_attr)
    &call parse_loop, s_attr
        &call if_match_continue, \s+
            #-- skip --
        &call if_match_continue, /
            #-- self closing --
            tag['/']=1
        &call if_match_continue, ([^\s'\"\\=<>`]+)
            #-- got a name --
            s_attr_name=m.group(1)
            #-- = --
            &call if_match_single, \s*=\s*
                $call parse_attr_value
            $else
                tag[s_attr_name]=1
    # -----
    subcode: parse_attr_value
        &call sub_loop
            &call if_match_break, \"((?:[^\\\"]+|\\.)*)\"
                tag[s_attr_name] = m.group(1)
            &call if_match_break, '((?:[^\\\']+|\\.)*)'
                tag[s_attr_name] = m.group(1)
            &call if_match_break, [^\s'\"=<>`]+
                tag[s_attr_name] = m.group(0)
            #-- error --
            i+=1
                    
#-------------------------------
subcode: parse_loop(s)
    $import re
    n=len($(s))
    i=0
    while i<n:
        BLOCK

    subcode: sub_loop
        while i<n:
            BLOCK

    subcode: if_match(break)
        $(autoinc:re)
        $(block:regex_compile)
            re$(re) = re.compile(r"$(pattern)")
        m = re$(re).match($(s)[i:])
        # m = re.match(r"$(pattern)", $(s)[i:])
        if m:
            i+=m.end()
            BLOCK
            $(if:break!=single)
                $(break)

    subcode: if_match_single(@pattern)
        &call if_match, single
            BLOCK

    subcode: if_match_continue(@pattern)
        &call if_match, continue
            BLOCK

    subcode: if_match_break(@pattern)
        &call if_match, break
            BLOCK

#---------------------------------------- 
fncode: debug_dom(node)
    $def print_node(node, level)
        $if isinstance(node, str)
            print "    " * level, node
        $else
            print "    " * level, node['_name']
            $if "_list" in node
                $for t in node['_list']
                    print_node(t, level+1)

    print_node(node, 0)


